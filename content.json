{"pages":[],"posts":[{"title":"go test报错 wrong signature for TestAdd, must be: func TestAdd(t *testing.T)","text":"参考: https://www.cnblogs.com/mingbai/p/gotesterr.html 背景学习 Go 过程中，在终端输入 go test 显示报错: 1$ wrong signature for TestAdd, must be: func TestAdd(t *testing.T) 后经搜索该报错查明示由于 func TestAdd(t testing.T) 参数未带 *，需要改为 func TestAdd(t *testing.T) 问题复现报错代码如下: 12345678910111213141516171819// calculation_util_test.gopackage calculation_utilimport &quot;testing&quot;func TestAdd(t testing.T) { tests := []struct{ a, b, c int }{ {1, 2, 3}, {1, 3, 4}, {1, 1, 2}, } for _, test := range tests { actualVal := Add(test.a, test.b) expectVal := test.c if actualVal != expectVal { t.Errorf(&quot;Add(%d, %d) actualVal: %d, but expectVal: %d&quot;, test.a, test.b, actualVal, expectVal) } }} 如何解决修改后的代码: 12345678910111213141516171819// calculation_util_test.gopackage calculation_utilimport &quot;testing&quot;func TestAdd(t *testing.T) { tests := []struct{ a, b, c int }{ {1, 2, 3}, {1, 3, 4}, {1, 1, 2}, } for _, test := range tests { actualVal := Add(test.a, test.b) expectVal := test.c if actualVal != expectVal { t.Errorf(&quot;Add(%d, %d) actualVal: %d, but expectVal: %d&quot;, test.a, test.b, actualVal, expectVal) } }} 测试通过！","link":"/2021/09/21/go-test%E6%8A%A5%E9%94%99-wrong-signature-for-TestAdd-must-be-func-TestAdd-t-testing-T/"},{"title":"Go语言中占位符的使用","text":"原文地址: https://studygolang.com/articles/21039 定义示例类型和变量1234type Human struct { Name string}var people = Human{Name:&quot;zhangsan&quot;} 1. 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式。 Printf(“%v”, people) {zhangsan} %+v 打印结构体时，会添加字段名 Printf(“%+v”, people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(“#v”, people) main.Human{Name:”zhangsan”} %T 相应值的类型的Go语法表示 Printf(“%T”, people) main.Human %% 字面上的百分号，并非值的占位符 Printf(“%%”) % 2. 布尔占位符 占位符 说明 举例 输出 %t true 或 false Printf(“%t”, true) true 3. 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(“%b”, 5) 101 %c 相应Unicode码点所表示的字符 Printf(“%c”, 0x4E2D) 中 %d 十进制表示 Printf(“%d”, 0x12) 18 %o 八进制表示 Printf(“%d”, 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(“%q”, 0x4E2D) ‘中’ %x 十六进制表示，字母形式为小写 a-f Printf(“%x”, 13) d %X 十六进制表示，字母形式为大写 A-F Printf(“%x”, 13) D %U Unicode格式：U+1234，等同于 “U+%04X” Printf(“%U”, 0x4E2D) U+4E2D 4. 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %b 无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 ‘b’ 转换格式一致。例如 -123456p-78 %e 科学计数法，例如 -1234.456e+78 Printf(“%e”, 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(“%e”, 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(“%f”, 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%g”, 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%G”, 10.20+2i) (10.2+2i) 5. 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(“%s”, []byte(“Go语言”)) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(“%q”, “Go语言”) “Go语言” %x 十六进制，小写字母，每字节两个字符 Printf(“%x”, “golang”) 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(“%X”, “golang”) 676F6C616E67 6. 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(“%p”, &amp;people) 0x4f57f0 7. 其他标记 占位符 说明 举例 输出 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 Printf(“%+q”, “中文”) “\\u4e2d\\u6587” - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o） 为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x； 如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串； 如果是可打印字符，%U（%#U）会写出该字符的 Unicode 编码形式（如字符 x 会被打印成 U+0078 ‘x’）。 Printf(“%#U”, ‘中’) U+4E2D ‘ ‘ (空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 8. 其他golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。 宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。 对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。 %e 和 %f 的默认精度为6 对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。 而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。","link":"/2021/09/21/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"base64 及 base64 url-safe","text":"背景在一次开发中，服务端需要接受某个参数为 base64 编码的值，测试所得服务端所得的编码值无法与前端所传的值匹配不上，即所传的参数不是服务端所需的正确的编码值。后联调得知，服务端需要接收的是 base64 url-safe 的值，所以前端需要也对数据进行 base64 编码为 url-safe 的值。 遇到问题的相关 issue: https://github.com/brix/crypto-js/issues/252 问题复现12345// 有效的 base64 字符如下: // ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=// 因为 base64 字符串可以包含“+”、“=”和“/”字符，这些字符可能会改变数据的含义// JavaScript 中可以通过 btoa 对字符串进行 base64 编码const ret = btoa(data); 如何解决1const ret = btoa(data).replace(/\\//g, '_').replace(/\\+/g, '-');","link":"/2021/09/21/base64%E5%8F%8Abase64-url-safe/"},{"title":"Chrome 中 post 请求体过大导请求体和响应体无法正常展示","text":"背景Chrome 版本: 版本 95.0.4638.54（正式版本） (arm64) 机型如下: macOS Big Sur MacBook Pro (13-inch, M1, 2020) 芯片 Apple M1 内存 16GB 一次开发中，一个 post 请求的请求体含有多个 base64 数据，在 Chrome 中请求后遇到如下问题: http 响应 500 (服务端错误，忽略) 请求体消失了 响应体无法显示 在服务端 500 问题修复之后，起初以为请求体和响应体不显示的问题会导致请求体丢失导致无法正常响应，可是发现只是 Chrome 中在控制台中无法正常预览，但是请求和响应都是正常的，也有数据正常返回。 于是猜想只是并不影响请求和响应，只是无法正常在控制台进行数据预览。 验证猜想12345678910111213141516171819202122232425// 服务端const http = require('http');const server = http.createServer((req, res) =&gt; { if (req.url === '/test' &amp;&amp; req.method.toLowerCase() === 'post') { res.writeHead(200, { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Headers': 'X-Requested-With,Content-Type', 'Access-Control-Allow-Methods': 'PUT,POST,GET,DELETE,OPTIONS' }); let data = ''; req.on('data', chunk =&gt; { data += chunk; }); req.on('end', () =&gt; { res.end(JSON.stringify({ method: req.method, message: 'ok', data: JSON.parse(data) })); }) }})server.listen(8000); 1234567891011121314// 前端function main() { const b64 = 'xxx' // 由于 base64 太大了，这里就用伪代码代替了。 fetch('http://localhost:8000/test', { method: 'POST', body: JSON.stringify({ base64: Array(20).fill(b64) }) }).then(response =&gt; response.json()).then(response =&gt; { console.log('response', response) })}main(); 效果如下所示: 可见无法正常预览，请求体也没了! 当你修改 base64 的值，改为 base64: Array(10).fill(b64) 发现就可以正常预览了:","link":"/2021/10/21/Chrome-%E4%B8%AD-post-%E8%AF%B7%E6%B1%82%E4%BD%93%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%AF%B7%E6%B1%82%E4%BD%93%E5%92%8C%E5%93%8D%E5%BA%94%E4%BD%93%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B1%95%E7%A4%BA/"},{"title":"Mock.js 拦截了二进制流数据的请求.md","text":"背景在一次开发中，客户提出我们提供的 SDK 无法正常使用，但是我们提供的 demo 可以正常使用。后经对比排查发现，客户的项目中引入了 Mock.js 而导致的 SDK 中对二进制资源的请求被拦截并进行了处理，导致请求的资源发生错误。 产生的原因后通过在 Mock.js 的 repo issues 里也有搜索到 相关 issue。 原因在于引入 Mock.js 发出请求后，服务器端返回的文件为二进制流，原生请求会正常的将其作为 blob 对象返回，而 Mock.js 则会将其转为字符串，Mock.js 完全重写了原生的 XMLHttpRequest。 如何解决可以参考该 commit: https://github.com/Hugo-X/Mock/commit/2a6cc9ce7cfa407ce0036c187a6de1803f567884 修改 Mock.js 源码来解决这个问题。 也可以使用 better-mock 替代 Mock.js。","link":"/2021/10/17/Mock-js-%E6%8B%A6%E6%88%AA%E4%BA%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%B7%E6%B1%82-md/"},{"title":"Nginx 正则配置实现带版本号请求页面","text":"需求背景访问 https://www.xxx.com/1.0.0/ 响应 1.0.0 版本的页面。 访问 https://www.xxx.com/1.0.1/ 响应 1.0.1 版本的页面。 访问 https://www.xxx.com/1.0.2/ 响应 1.0.2 版本的页面。 以此类推… History 模式路由在部署 History 模式路由的页面的时候，我们需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。 Nginx 配置如下： 123location / { try_files $uri $uri/ /index.html;} 参考：https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90 编写页面src/main.tsx12345678import React from 'react'import ReactDOM from 'react-dom'import App from './App'ReactDOM.render( &lt;App /&gt;, document.getElementById('root')) src/App.tsx12345678910111213141516171819import { CSSProperties } from 'react'import IRouter from './IRouter'const containerStyle: CSSProperties = { position: 'absolute', left: '50%', top: '50%', transform: 'translate(-50%, -50%)'}const App = () =&gt; { const version = projectVersion; return &lt;div style={containerStyle}&gt; &lt;div&gt;version: {version}&lt;/div&gt; &lt;IRouter /&gt; &lt;/div&gt;}export default App; src/IRouter.tsx1234567891011121314151617import React from 'react'import { BrowserRouter, Redirect, Route, Switch } from 'react-router-dom'import Login from './pages/login/login'import Home from './pages/home/home'const IRouter = () =&gt; { const version = projectVersion; return &lt;BrowserRouter basename={process.env.NODE_ENV === 'production' ? `/${version}` : '/'}&gt; &lt;Switch&gt; &lt;Route exact path='/login' component={Login}/&gt; &lt;Route exact path='/home' component={Home}/&gt; &lt;Redirect to='/login' /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt;}export default IRouter src/pages/home.tsx:123456789101112// home.tsximport { useHistory } from 'react-router-dom'const Home = () =&gt; { const history = useHistory(); return &lt;div&gt; Home &lt;button onClick={() =&gt; history.push('/login')}&gt;to login&lt;/button&gt; &lt;/div&gt;}export default Home; src/pages/login.tsx:123456789101112// login.tsximport { useHistory } from 'react-router-dom'const Login = () =&gt; { const history = useHistory(); return &lt;div&gt; Login &lt;button onClick={() =&gt; history.push('/home')}&gt;to home&lt;/button&gt; &lt;/div&gt;}export default Login; vite.config.ts1234567891011121314import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'const packageJson = require('./package.json');console.log('process.env.NODE_ENV', process.env.NODE_ENV)// https://vitejs.dev/config/export default defineConfig({ plugins: [react()], define: { projectVersion: JSON.stringify(packageJson.version) }, base: './'}) 基础配置首先我们先解决部署 History 模式路由 配置如下： 12345location / { root html; try_files $uri $uri/ /index.html; index index.html index.htm;} 配置成功，你就可以正常访问页面了，如下图所示： 如果不进行 try_files 配置的话，刷新页面会得到 404 页面，如下图所示： 需求实现首先实现手动配置版本： 123456789101112131415location /1.0.0/ { root html; try_files $uri /1.0.0/index.html; index index.html index.htm;}location /1.0.1/ { root html; try_files $uri /1.0.1/index.html; index index.html index.htm;}location /1.0.2/ { root html; try_files $uri /1.0.2/index.html; index index.html index.htm;} 正则匹配版本： 12345location ~* /(.*)/ { root html; try_files $uri /$1/index.html; index index.html index.htm;} 测试，访问正常~ 踩坑记录最开始配置正则的时候，发现正则是对的，但是一直配置不成功。 后面搜索发现是需要遵循 location 的语法规则的。 Nginx配置中Location的语法规则 location [ = | ~ | ~* | ^~ | !~ | !~* ] /uri/{ … } = 表示精确匹配 ~ 表示区分大小写正则匹配 ~* 表示不区分大小写正则匹配 ^~ 表示URI以某个常规字符串开头 !~ 表示区分大小写正则不匹配 !~* 表示不区分大小写正则不匹配 / 通用匹配，任何请求都会匹配到 参考文章：https://juejin.cn/post/6844903992871370766 注： 其中还需要注意下打包的路径，不然会发生静态资源访问发生错误。","link":"/2021/10/19/Nginx-%E6%AD%A3%E5%88%99%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E5%B8%A6%E7%89%88%E6%9C%AC%E5%8F%B7%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2/"},{"title":"Vite 无法通过 import xxx from &#39;path&#x2F;xxx.umd.js&#39; 的方式正常引入 UMD 模块使用","text":"背景首先打包出一个 umd 模块的 js 库，这里用 add.umd.js 来表示这个库吧。 然后测试发现： 在 create-react-app 的项目中通过 import add from 'path/add.umd.js' 方式可以正常引入并使用 在 Vite 的项目中(个人测试是通过 yarn create vite 选择 react-ts 模板生成) import add from 'path/add.umd.js' 无法正常导入并使用。然而通过 import 'path/add.umd.js' 却可以正常导入，使用姿势大致如下所示： 123import 'path/add.umd.js';console.log(window.add); 原因最初以为 create-react-app 对 webpack 进行了配置使得其能像 import ESM 模块一样去 import UMD 模块，后经测试 webpack 天生支持。 然后翻阅了 Vite 的官方文档： CommonJS 和 UMD 兼容性: 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。 相关链接： https://cn.vitejs.dev/guide/features.html#npm-dependency-resolving-and-pre-bundling https://cn.vitejs.dev/guide/dep-pre-bundling.html#the-why 然后测试所得我们并没法正常导入，后通过提 issue 得到回答： Vite 支持在 node_modules 内部转换依赖项以实现兼容性。 但是来自用户项目的文件应该始终是 ESM。 相关 issue：https://github.com/vitejs/vite/issues/4520","link":"/2021/10/20/Vite-%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87-import-xxx-from-xxx-umd-js-%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AD%A3%E5%B8%B8%E5%BC%95%E5%85%A5%E4%BD%BF%E7%94%A8/"},{"title":"在网站搭建初期给z-index 分层规范","text":"一般来说前端架构师在网站搭建初期就要给 z index 分层： 0+ 用于普通内容 16+ 用于导航 32+ 用于导航菜单 64+ 用于 tooltip 128+ 用于 popover 256+ 用于对话框 1024+ 用于 loading 类似这样","link":"/2021/12/06/%E5%9C%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E5%88%9D%E6%9C%9F%E7%BB%99z-index-%E5%88%86%E5%B1%82%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Vite","slug":"Vite","link":"/tags/Vite/"}],"categories":[]}