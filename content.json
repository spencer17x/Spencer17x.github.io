{"pages":[],"posts":[{"title":"Chrome 中 post 请求体过大导请求体和响应体无法正常展示","text":"背景Chrome 版本: 版本 95.0.4638.54（正式版本） (arm64) 机型如下: macOS Big Sur MacBook Pro (13-inch, M1, 2020) 芯片 Apple M1 内存 16GB 一次开发中，一个 post 请求的请求体含有多个 base64 数据，在 Chrome 中请求后遇到如下问题: http 响应 500 (服务端错误，忽略) 请求体消失了 响应体无法显示 在服务端 500 问题修复之后，起初以为请求体和响应体不显示的问题会导致请求体丢失导致无法正常响应，可是发现只是 Chrome 中在控制台中无法正常预览，但是请求和响应都是正常的，也有数据正常返回。 于是猜想只是并不影响请求和响应，只是无法正常在控制台进行数据预览。 验证猜想12345678910111213141516171819202122232425// 服务端const http = require('http');const server = http.createServer((req, res) =&gt; { if (req.url === '/test' &amp;&amp; req.method.toLowerCase() === 'post') { res.writeHead(200, { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Headers': 'X-Requested-With,Content-Type', 'Access-Control-Allow-Methods': 'PUT,POST,GET,DELETE,OPTIONS' }); let data = ''; req.on('data', chunk =&gt; { data += chunk; }); req.on('end', () =&gt; { res.end(JSON.stringify({ method: req.method, message: 'ok', data: JSON.parse(data) })); }) }})server.listen(8000); 1234567891011121314// 前端function main() { const b64 = 'xxx' // 由于 base64 太大了，这里就用伪代码代替了。 fetch('http://localhost:8000/test', { method: 'POST', body: JSON.stringify({ base64: Array(20).fill(b64) }) }).then(response =&gt; response.json()).then(response =&gt; { console.log('response', response) })}main(); 效果如下所示: 可见无法正常预览，请求体也没了! 当你修改 base64 的值，改为 base64: Array(10).fill(b64) 发现就可以正常预览了:","link":"/2021/10/21/Chrome-%E4%B8%AD-post-%E8%AF%B7%E6%B1%82%E4%BD%93%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%AF%B7%E6%B1%82%E4%BD%93%E5%92%8C%E5%93%8D%E5%BA%94%E4%BD%93%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B1%95%E7%A4%BA/"},{"title":"Go语言中占位符的使用","text":"原文地址: https://studygolang.com/articles/21039 定义示例类型和变量1234type Human struct { Name string}var people = Human{Name:&quot;zhangsan&quot;} 1. 普通占位符 占位符 说明 举例 输出 %v 相应值的默认格式。 Printf(“%v”, people) {zhangsan} %+v 打印结构体时，会添加字段名 Printf(“%+v”, people) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(“#v”, people) main.Human{Name:”zhangsan”} %T 相应值的类型的Go语法表示 Printf(“%T”, people) main.Human %% 字面上的百分号，并非值的占位符 Printf(“%%”) % 2. 布尔占位符 占位符 说明 举例 输出 %t true 或 false Printf(“%t”, true) true 3. 整数占位符 占位符 说明 举例 输出 %b 二进制表示 Printf(“%b”, 5) 101 %c 相应Unicode码点所表示的字符 Printf(“%c”, 0x4E2D) 中 %d 十进制表示 Printf(“%d”, 0x12) 18 %o 八进制表示 Printf(“%d”, 10) 12 %q 单引号围绕的字符字面值，由Go语法安全地转义 Printf(“%q”, 0x4E2D) ‘中’ %x 十六进制表示，字母形式为小写 a-f Printf(“%x”, 13) d %X 十六进制表示，字母形式为大写 A-F Printf(“%x”, 13) D %U Unicode格式：U+1234，等同于 “U+%04X” Printf(“%U”, 0x4E2D) U+4E2D 4. 浮点数和复数的组成部分（实部和虚部） 占位符 说明 举例 输出 %b 无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 ‘b’ 转换格式一致。例如 -123456p-78 %e 科学计数法，例如 -1234.456e+78 Printf(“%e”, 10.2) 1.020000e+01 %E 科学计数法，例如 -1234.456E+78 Printf(“%e”, 10.2) 1.020000E+01 %f 有小数点而无指数，例如 123.456 Printf(“%f”, 10.2) 10.200000 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%g”, 10.20) 10.2 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出 Printf(“%G”, 10.20+2i) (10.2+2i) 5. 字符串与字节切片 占位符 说明 举例 输出 %s 输出字符串表示（string类型或[]byte) Printf(“%s”, []byte(“Go语言”)) Go语言 %q 双引号围绕的字符串，由Go语法安全地转义 Printf(“%q”, “Go语言”) “Go语言” %x 十六进制，小写字母，每字节两个字符 Printf(“%x”, “golang”) 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(“%X”, “golang”) 676F6C616E67 6. 指针 占位符 说明 举例 输出 %p 十六进制表示，前缀 0x Printf(“%p”, &amp;people) 0x4f57f0 7. 其他标记 占位符 说明 举例 输出 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 Printf(“%+q”, “中文”) “\\u4e2d\\u6587” - 在右侧而非左侧填充空格（左对齐该区域） # 备用格式：为八进制添加前导 0（%#o） 为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x； 如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串； 如果是可打印字符，%U（%#U）会写出该字符的 Unicode 编码形式（如字符 x 会被打印成 U+0078 ‘x’）。 Printf(“%#U”, ‘中’) U+4E2D ‘ ‘ (空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后 8. 其他golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。 宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。 对于 %g/%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。 %e 和 %f 的默认精度为6 对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。 而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。","link":"/2021/09/21/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Mock.js 拦截了二进制流数据的请求.md","text":"背景在一次开发中，客户提出我们提供的 SDK 无法正常使用，但是我们提供的 demo 可以正常使用。后经对比排查发现，客户的项目中引入了 Mock.js 而导致的 SDK 中对二进制资源的请求被拦截并进行了处理，导致请求的资源发生错误。 产生的原因后通过在 Mock.js 的 repo issues 里也有搜索到 相关 issue。 原因在于引入 Mock.js 发出请求后，服务器端返回的文件为二进制流，原生请求会正常的将其作为 blob 对象返回，而 Mock.js 则会将其转为字符串，Mock.js 完全重写了原生的 XMLHttpRequest。 如何解决可以参考该 commit: https://github.com/Hugo-X/Mock/commit/2a6cc9ce7cfa407ce0036c187a6de1803f567884 修改 Mock.js 源码来解决这个问题。 也可以使用 better-mock 替代 Mock.js。","link":"/2021/10/17/Mock-js-%E6%8B%A6%E6%88%AA%E4%BA%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%B7%E6%B1%82-md/"},{"title":"Vite 无法通过 import xxx from &#39;path&#x2F;xxx.umd.js&#39; 的方式正常引入 UMD 模块使用","text":"背景首先打包出一个 umd 模块的 js 库，这里用 add.umd.js 来表示这个库吧。 然后测试发现： 在 create-react-app 的项目中通过 import add from 'path/add.umd.js' 方式可以正常引入并使用 在 Vite 的项目中(个人测试是通过 yarn create vite 选择 react-ts 模板生成) import add from 'path/add.umd.js' 无法正常导入并使用。然而通过 import 'path/add.umd.js' 却可以正常导入，使用姿势大致如下所示： 123import 'path/add.umd.js';console.log(window.add); 原因最初以为 create-react-app 对 webpack 进行了配置使得其能像 import ESM 模块一样去 import UMD 模块，后经测试 webpack 天生支持。 然后翻阅了 Vite 的官方文档： CommonJS 和 UMD 兼容性: 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。 相关链接： https://cn.vitejs.dev/guide/features.html#npm-dependency-resolving-and-pre-bundling https://cn.vitejs.dev/guide/dep-pre-bundling.html#the-why 然后测试所得我们并没法正常导入，后通过提 issue 得到回答： Vite 支持在 node_modules 内部转换依赖项以实现兼容性。 但是来自用户项目的文件应该始终是 ESM。 相关 issue：https://github.com/vitejs/vite/issues/4520","link":"/2021/10/20/Vite-%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87-import-xxx-from-xxx-umd-js-%E7%9A%84%E6%96%B9%E5%BC%8F%E6%AD%A3%E5%B8%B8%E5%BC%95%E5%85%A5%E4%BD%BF%E7%94%A8/"},{"title":"Nginx 正则配置实现带版本号请求页面","text":"需求背景访问 https://www.xxx.com/1.0.0/ 响应 1.0.0 版本的页面。 访问 https://www.xxx.com/1.0.1/ 响应 1.0.1 版本的页面。 访问 https://www.xxx.com/1.0.2/ 响应 1.0.2 版本的页面。 以此类推… History 模式路由在部署 History 模式路由的页面的时候，我们需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。 Nginx 配置如下： 123location / { try_files $uri $uri/ /index.html;} 参考：https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90 编写页面src/main.tsx12345678import React from 'react'import ReactDOM from 'react-dom'import App from './App'ReactDOM.render( &lt;App /&gt;, document.getElementById('root')) src/App.tsx12345678910111213141516171819import { CSSProperties } from 'react'import IRouter from './IRouter'const containerStyle: CSSProperties = { position: 'absolute', left: '50%', top: '50%', transform: 'translate(-50%, -50%)'}const App = () =&gt; { const version = projectVersion; return &lt;div style={containerStyle}&gt; &lt;div&gt;version: {version}&lt;/div&gt; &lt;IRouter /&gt; &lt;/div&gt;}export default App; src/IRouter.tsx1234567891011121314151617import React from 'react'import { BrowserRouter, Redirect, Route, Switch } from 'react-router-dom'import Login from './pages/login/login'import Home from './pages/home/home'const IRouter = () =&gt; { const version = projectVersion; return &lt;BrowserRouter basename={process.env.NODE_ENV === 'production' ? `/${version}` : '/'}&gt; &lt;Switch&gt; &lt;Route exact path='/login' component={Login}/&gt; &lt;Route exact path='/home' component={Home}/&gt; &lt;Redirect to='/login' /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt;}export default IRouter src/pages/home.tsx:123456789101112// home.tsximport { useHistory } from 'react-router-dom'const Home = () =&gt; { const history = useHistory(); return &lt;div&gt; Home &lt;button onClick={() =&gt; history.push('/login')}&gt;to login&lt;/button&gt; &lt;/div&gt;}export default Home; src/pages/login.tsx:123456789101112// login.tsximport { useHistory } from 'react-router-dom'const Login = () =&gt; { const history = useHistory(); return &lt;div&gt; Login &lt;button onClick={() =&gt; history.push('/home')}&gt;to home&lt;/button&gt; &lt;/div&gt;}export default Login; vite.config.ts1234567891011121314import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'const packageJson = require('./package.json');console.log('process.env.NODE_ENV', process.env.NODE_ENV)// https://vitejs.dev/config/export default defineConfig({ plugins: [react()], define: { projectVersion: JSON.stringify(packageJson.version) }, base: './'}) 基础配置首先我们先解决部署 History 模式路由 配置如下： 12345location / { root html; try_files $uri $uri/ /index.html; index index.html index.htm;} 配置成功，你就可以正常访问页面了，如下图所示： 如果不进行 try_files 配置的话，刷新页面会得到 404 页面，如下图所示： 需求实现首先实现手动配置版本： 123456789101112131415location /1.0.0/ { root html; try_files $uri /1.0.0/index.html; index index.html index.htm;}location /1.0.1/ { root html; try_files $uri /1.0.1/index.html; index index.html index.htm;}location /1.0.2/ { root html; try_files $uri /1.0.2/index.html; index index.html index.htm;} 正则匹配版本： 12345location ~* /(.*)/ { root html; try_files $uri /$1/index.html; index index.html index.htm;} 测试，访问正常~ 踩坑记录最开始配置正则的时候，发现正则是对的，但是一直配置不成功。 后面搜索发现是需要遵循 location 的语法规则的。 Nginx配置中Location的语法规则 location [ = | ~ | ~* | ^~ | !~ | !~* ] /uri/{ … } = 表示精确匹配 ~ 表示区分大小写正则匹配 ~* 表示不区分大小写正则匹配 ^~ 表示URI以某个常规字符串开头 !~ 表示区分大小写正则不匹配 !~* 表示不区分大小写正则不匹配 / 通用匹配，任何请求都会匹配到 参考文章：https://juejin.cn/post/6844903992871370766 注： 其中还需要注意下打包的路径，不然会发生静态资源访问发生错误。","link":"/2021/10/19/Nginx-%E6%AD%A3%E5%88%99%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E5%B8%A6%E7%89%88%E6%9C%AC%E5%8F%B7%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2/"},{"title":"base64 及 base64 url-safe","text":"背景在一次开发中，服务端需要接受某个参数为 base64 编码的值，测试所得服务端所得的编码值无法与前端所传的值匹配不上，即所传的参数不是服务端所需的正确的编码值。后联调得知，服务端需要接收的是 base64 url-safe 的值，所以前端需要也对数据进行 base64 编码为 url-safe 的值。 遇到问题的相关 issue: https://github.com/brix/crypto-js/issues/252 问题复现12345// 有效的 base64 字符如下: // ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=// 因为 base64 字符串可以包含“+”、“=”和“/”字符，这些字符可能会改变数据的含义// JavaScript 中可以通过 btoa 对字符串进行 base64 编码const ret = btoa(data); 如何解决1const ret = btoa(data).replace(/\\//g, '_').replace(/\\+/g, '-');","link":"/2021/09/21/base64%E5%8F%8Abase64-url-safe/"},{"title":"关于 Chrome 音视频自动播放的问题","text":"在 Chrome 音视频播放的时候，play() 返回的是一个 promise，当播放失败的时候一般会显示一个按钮让用户手动进行播放。 但是在浏览其他大型视频网站的时候，会发现他们的网站貌似没出现过该问题。于是去查阅了相关资料。 其实最主要查看 https://developer.chrome.com/blog/autoplay 即可得到答案。 总结就是 Chrome 有个自动播放的策略。 Chrome 中的自动播放策略改善用户体验，减少安装广告拦截器的动机，并减少数据消耗 Chrome 66 中针对音频和视频元素推出的自动播放策略有效地阻止了 Chrome 中大约一半不需要的媒体自动播放。对于 Web Audio API，在 Chrome 71 中启动了自动播放策略。这会影响网络游戏、某些 WebRTC 应用程序和其他使用音频功能的网页。更多详细信息可以在下面的 Web Audio API 部分中找到。 Chrome 的自动播放政策在 2018 年 4 月发生了变化 新行为您可能已经注意到，Web 浏览器正朝着更严格的自动播放策略发展，以改善用户体验，最大限度地减少安装广告拦截器的动机，并减少昂贵和/或受限网络上的数据消耗。这些更改旨在为用户提供更大的播放控制权，并通过合法用例使发布者受益。 Chrome 的自动播放策略很简单： 始终允许静音自动播放。 在以下情况下允许自动播放声音： 用户与域进行了交互（单击、点击等）。 在桌面上，用户的媒体参与指数阈值已被超过，这意味着用户之前播放过有声视频。 用户已将网站添加到移动设备的主屏幕或在桌面设备上安装 PWA。 顶级 frames 可以将自动播放权限委托给其 iframe 以允许自动播放声音。 媒体参与指数媒体参与指数 (MEI) 衡量个人在网站上消费媒体的倾向。 Chrome 的方法是每个来源的访问与重要媒体播放事件的比率： 媒体（音频/视频）的消耗必须大于七秒。 音频必须存在且未静音。 带有视频的选项卡处于活动状态。 视频大小（以像素为单位）必须大于 200x140。 Chrome 从中计算出媒体参与度得分，该得分在定期播放媒体的网站上最高。当它足够高时，媒体只允许在桌面上自动播放。 用户的 MEI 位于 about://media-engagement 内部页面。 开发者开关作为开发者，您可能希望在本地更改 Chrome 自动播放政策行为，以测试您的网站的不同用户参与度。 您可以使用命令行标志完全禁用自动播放策略：chrome.exe –autoplay-policy=no-user-gesture-required。这使您可以测试您的网站，就好像用户与您的网站密切互动一样，并且始终允许播放自动播放。 您还可以决定通过禁用 MEI 来确保永远不允许自动播放，以及是否默认为新用户自动播放具有最高总体 MEI 的站点。使用标志执行此操作：chrome.exe –disable-features=PreloadMediaEngagementData、MediaEngagementBypassAutoplayPolicies。 iframe 委托权限策略允许开发人员有选择地启用和禁用浏览器功能和 API。一旦源获得了自动播放权限，它就可以将该权限委托给具有自动播放权限策略的跨源 iframe。请注意，默认情况下，同源 iframe 上允许自动播放。 12345&lt;!-- Autoplay is allowed. --&gt;&lt;iframe src=&quot;https://cross-origin.com/myvideo.html&quot; allow=&quot;autoplay&quot;&gt;&lt;!-- Autoplay and Fullscreen are allowed. --&gt;&lt;iframe src=&quot;https://cross-origin.com/myvideo.html&quot; allow=&quot;autoplay; fullscreen&quot;&gt; 当自动播放的权限策略被禁用时，在没有用户手势的情况下调用 play() 将拒绝带有 NotAllowedError DOMException 的承诺。并且自动播放属性也将被忽略。 警告：较早的文章错误地建议使用不受支持的属性gesture=media。 例子示例 1：每次用户在笔记本电脑上访问 VideoSubscriptionSite.com 时，他们都会观看电视节目或电影。由于他们的媒体参与度得分很高，因此允许自动播放。 示例 2：GlobalNewsSite.com 包含文本和视频内容。大多数用户只是偶尔访问该站点以获取文本内容并观看视频。用户的媒体参与度得分较低，因此如果用户直接从社交媒体页面或搜索导航，则不允许自动播放。 示例 3：LocalNewsSite.com 同时包含文本和视频内容。大多数人通过主页进入网站，然后点击新闻文章。由于用户与域的交互，将允许在新闻文章页面上自动播放。但是，应注意确保用户不会对自动播放内容感到惊讶。 示例 4：MyMovieReviewBlog.com 嵌入了一个带有电影预告片的 iframe，以配合评论。用户与域交互以访问博客，因此允许自动播放。但是，博客需要将该权限明确委派给 iframe，以便内容自动播放。 Chrome 企业政策对于自助服务终端或无人值守系统等用例，可以使用 Chrome 企业策略更改自动播放行为。查看策略列表帮助页面，了解如何设置自动播放相关的企业策略： AutoplayAllowed 策略控制是否允许自动播放。 AutoplayAllowlist 策略允许您指定始终启用自动播放的 URL 模式的允许列表。 Web 开发人员的最佳实践Audio/Video 元素这是要记住的一件事：永远不要假设视频会播放，也不要在视频未实际播放时显示暂停按钮。这非常重要，我将在下面再写一次，以供那些只是浏览该帖子的人使用。 陷阱：不要假设视频会播放，也不要在视频未实际播放时显示暂停按钮。 您应该始终查看 play 函数返回的 Promise 以查看它是否被拒绝： 12345678910var promise = document.querySelector('video').play();if (promise !== undefined) { promise.then(_ =&gt; { // Autoplay started! }).catch(error =&gt; { // Autoplay was prevented. // Show a &quot;Play&quot; button so that user can start playback. });} 不要在没有显示任何媒体控件的情况下播放插页式广告，因为它们可能不会自动播放，用户将无法开始播放。 吸引用户的一种很酷的方法是使用静音自动播放并让他们选择取消静音。 （参见下面的示例。）一些网站已经有效地做到了这一点，包括 Facebook、Instagram、Twitter 和 YouTube。 12345678&lt;video id=&quot;video&quot; muted autoplay&gt;&lt;button id=&quot;unmuteButton&quot;&gt;&lt;/button&gt;&lt;script&gt; unmuteButton.addEventListener('click', function() { video.muted = false; });&lt;/script&gt; 触发用户激活的事件仍然需要跨浏览器一致地定义。我建议你暂时坚持“点击”。请参阅 GitHub 问题 whatwg/html#3849。 Web Audio自 Chrome 71 起，自动播放就涵盖了 Web Audio API。关于它有一些事情需要了解。首先，在开始音频播放之前等待用户交互是一种很好的做法，以便用户知道正在发生的事情。例如，想想“播放”按钮或“开/关”开关。您还可以根据应用程序的流程添加“取消静音”按钮。 如果在文档接收到用户手势之前创建了 AudioContext，它将在“暂停”状态下创建，您需要在用户手势之后调用 resume()。 如果您在页面加载时创建 AudioContext，则必须在用户与页面交互后的某个时间（例如，在用户单击按钮后）调用 resume()。或者，如果在任何附加节点上调用 start()，AudioContext 将在用户手势之后恢复。 12345678910111213// Existing code unchanged.window.onload = function() { var context = new AudioContext(); // Setup all nodes // ...}// One-liner to resume playback when user interacted with the page.document.querySelector('button').addEventListener('click', function() { context.resume().then(() =&gt; { console.log('Playback resumed successfully'); });}); 您也可以仅在用户与页面交互时创建 AudioContext。 12345document.querySelector('button').addEventListener('click', function() { var context = new AudioContext(); // Setup all nodes // ...}); 要检测浏览器是否需要用户交互来播放音频，请在创建 AudioContext.state 后检查它。如果允许播放，则应立即切换到运行。否则将被暂停。如果您监听 statechange 事件，您可以异步检测更改。 要查看示例，请查看为 https://airhorner.com 的这些自动播放策略规则修复 Web 音频播放的小型 Pull Request。 您可以在 Chromium 网站上找到 Chrome 自动播放功能的摘要。 相关链接： https://developer.chrome.com/blog/autoplay/ https://sites.google.com/a/chromium.org/dev/audio-video/autoplay https://github.com/gnipbao/iblog/issues/25 https://www.douyu.com/cms/gong/201807/06/8146.shtml https://chromeenterprise.google/policies/#AutoplayAllowed https://chromeenterprise.google/policies/#AutoplayAllowlist https://developers.google.com/web/updates/2017/06/play-request-was-interrupted","link":"/2022/02/18/%E5%85%B3%E4%BA%8E-Chrome-%E9%9F%B3%E8%A7%86%E9%A2%91%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"在网站搭建初期给z-index 分层规范","text":"一般来说前端架构师在网站搭建初期就要给 z index 分层： 0+ 用于普通内容 16+ 用于导航 32+ 用于导航菜单 64+ 用于 tooltip 128+ 用于 popover 256+ 用于对话框 1024+ 用于 loading 类似这样","link":"/2021/12/06/%E5%9C%A8%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E5%88%9D%E6%9C%9F%E7%BB%99z-index-%E5%88%86%E5%B1%82%E8%A7%84%E8%8C%83/"},{"title":"H5调用摄像头并切换摄像头","text":"文章摘自：https://blog.csdn.net/weixin_43864427/article/details/105771863 webRTC polyfill 的库: https://github.com/webrtcHacks/adapter 第一次启用成功调用前置摄像头，第二次需要调用后置却黑屏或者失败失败的原因很多，列举两个一开始我遇到的问题 前置摄像头调用后，摄像功能需要关闭后才能正常执行第二次调用，否则会报错：设备被占用。解决方法，在每次执行调用方法前，先关闭摄像设备。 12345if (window.stream) { window.stream.getTracks().forEach(track =&gt; { track.stop(); })} 调用后置API的方法还是无法唤醒后置摄像头，找到另外一个方法，通过查看手机摄像头ID，来直接唤醒后置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var deviceInfoId = &quot;&quot;, // 摄像头ID num = 0, // 摄像头数量 carema = []; // 摄像头ID数组 // 在页面加载完成后获得设备ID数组window.onload = navigator.mediaDevices.enumerateDevices().then(gotDevices);function gotDevices(deviceInfos) { for (let i = 0; i &lt; deviceInfos.length; ++i) { if (deviceInfos[i].kind === 'videoinput') { carema.push(deviceInfos[i].deviceId) } } deviceInfoId = carema[后置位置];}var constraints = { audio: false, video: { deviceId: deviceInfoId, // 放在app里面需要下面配置一下 &quot;permissions&quot;: { &quot;audio-capture&quot;: { &quot;description&quot;: &quot;Required to capture audio using getUserMedia()&quot; }, &quot;video-capture&quot;: { &quot;description&quot;: &quot;Required to capture video using getUserMedia()&quot; } } }};navigator.mediaDevices.getUserMedia(constraints).then(function (stream) { var video = document.getElementById('video'); try { window.stream = stream; video.srcObject = stream; } catch (error) { video.src = window.URL.createObjectURL(stream); } this.localMediaStream = stream; // 这个加不加好像没有影响 // video.play();}).catch(function (err) { console.log(err.name + &quot;: &quot; + err.message);}); 如果只是一部手机可以这样，但是测试了多部手机发现摄像头数组毫无规律可循，这个方法慎用。 如果页面上添加选择摄像设备的按钮的话，这个方法还是不错的。查看设备能调用几个摄像头链接如下：https://webrtc.github.io/samples/src/content/devices/input-output/ 部分手机打开摄像头以后是黑屏，但是拍照仍然可以成像解决方案：做了很多处理都没用，最后发现只要把参数中的分辨率（width,height）删除掉，就解决了黑屏问题 成功调用后用canvas实现成像并适应屏幕大小我这里的代码是取video的宽高然后复制给canvas，这样可以让canvas和video保持一致，只用给video设置宽度100%，高度调节成合适的值，就实现了适应手机屏幕。 12345678910111213var video = document.getElementById('video');var canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d'), CHeight = video.clientHeight, //获取屏幕大小让canvas自适应 CWidth = video.clientWidth;canvas.width = CWidth;canvas.height = CHeight;//localMediaStream 在data里定义一个{}if (localMediaStream) { ctx.drawImage(video, 0, 0, CWidth, CHeight); var dataURL = canvas.toDataURL('image/jpeg'); //dataURL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA' img.src = dataURL;} video 成像镜像问题API唤醒的前置摄像头是相反的，很不舒服很不舒服。 之后用css处理一下给video添加 transform: rotate(180deg),可以实现反转，但是还是没有达到和手机一样的效果。 这时候可以选择通过设备ID调用前置摄像头，前置摄像头的laval一直都是“default”，也有的是空值，但是也能实现。 配置代码如下： 1234567 var constraints = window.constraints = { audio: false, video: { sourceId: 'default', facingMode: { exact: &quot;user&quot; } }}; 完美调用自己手机的前置摄像头！！！ 完整代码如下： 1234567891011&lt;div @click='moveToCameraAVG()' v-cloak&gt; &lt;img v-if=&quot;imginfo!==''&quot; :src=&quot;imginfo&quot;/&gt; &lt;div class=&quot;warm_title2&quot;&gt;点击自拍一张头像&lt;/div&gt;&lt;/div&gt;&lt;video id=&quot;video&quot; class=&quot;pic_video&quot; playsinline autoplay x5-video-player-type=&quot;h5&quot; style='object-fit:fill'&gt;&lt;/video&gt;&lt;canvas id=&quot;canvas&quot; class=&quot;canvas_pic&quot; style='margin: 0;padding: 0;'&gt;&lt;/canvas&gt;&lt;div class=&quot;bottom_div&quot;&gt; &lt;div&gt;拍照&lt;/div&gt; &lt;img src='images/pic_btn.png' class=&quot;capture-btn&quot; @click='captureAvg'/&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576export default { // 头像相机 moveToCameraAVG() { var self = this; if (navigator.mediaDevices === undefined) { navigator.mediaDevices = {}; } if (navigator.mediaDevices.getUserMedia === undefined) { navigator.mediaDevices.getUserMedia = function (constraints) { var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia; if (!getUserMedia) { return Promise.reject(new Error('getUserMedia is not implemented in this browser')); } return new Promise(function (resolve, reject) { getUserMedia.call(navigator, constraints, resolve, reject); }); } } if (window.stream) { window.stream.getTracks().forEach(track =&gt; { track.stop(); }); } var constraints = window.constraints = { audio: false, video: { sourceId: 'default', facingMode: { exact: &quot;user&quot; } } }; navigator.mediaDevices.getUserMedia(constraints) .then(function (stream) { var video = document.getElementById('video'); try { window.stream = stream; video.srcObject = stream; } catch (error) { video.src = window.URL.createObjectURL(stream); } self.localMediaStream = stream; video.play(); }) .catch(function (err) { alert(err.name + &quot;: &quot; + err.message); }); }, // 停止摄像机 stopCapture: function () { var video = document.getElementById('video'); if (!video.srcObject) return let stream = video.srcObject let tracks = stream.getTracks(); tracks.forEach(track =&gt; { track.stop() }) }, // 头像照片 captureAvg() { var vm = this; var video = document.getElementById('video'); var canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d'), CHeight = video.clientHeight, //获取屏幕大小让canvas自适应 CWidth = video.clientWidth; canvas.width = CWidth; canvas.height = CHeight; if (vm.localMediaStream) { ctx.drawImage(video, 0, 0, CWidth, CHeight); var dataURL = canvas.toDataURL('image/jpeg'); //dataURL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA' vm.imginfo = dataURL; // 停止摄像机 video.pause(); this.stopCapture(); } }}","link":"/2022/02/18/H5%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E5%B9%B6%E5%88%87%E6%8D%A2%E6%91%84%E5%83%8F%E5%A4%B4/"},{"title":"document.querySelector() 无法使用以数字开头的 id","text":"一次开发中使用 document.querySelector 发现会报错 使用姿势如下： 1document.querySelector(`#{xxx}`) xxx 为服务端返回的 uuid 变量，经排查发现当 xxx 是数字开头的时候就会报错。 原因如下： document.querySelector(selectors) 中 selectors 规范是： 包含一个或多个要匹配的选择器的 DOM 字符串 DOMString。 该字符串必须是有效的CSS选择器字符串；如果不是，则引发SYNTAX_ERR异常。请参阅使用选择器定位DOM元素以获取有关选择器以及如何管理它们的更多信息。 提示:必须使用反斜杠字符转义不属于标准CSS语法的字符。 由于JavaScript也使用退格转义，因此在使用这些字符编写字符串文字时必须特别小心。 有关详细信息，请参阅Escaping special characters。 然而 document.getElementById() 就没这个问题。 相关链接: https://stackoverflow.com/questions/20306204/using-queryselector-with-ids-that-are-numbers","link":"/2022/02/18/document-querySelector-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E4%BB%A5%E6%95%B0%E5%AD%97%E5%BC%80%E5%A4%B4%E7%9A%84-id/"},{"title":"浏览器端如何在没有 HTTPS 环境下使用 WebRTC","text":"需求：两台pc设备通过rtc来建立连接进行音视频通话。 相关issue：https://github.com/pili-engineering/QNRTC-Web/issues/54 电脑系统及版本：macOS Catalina 10.15.7 (19H15)当前浏览器版本：版本 90.0.4430.85（正式版本） (x86_64) 方案1：参考：https://blog.csdn.net/qq_40556950/article/details/105048931 方法一。 注：记得添加端口号，不然无效的。 方案2：参考：https://juejin.cn/post/6844903848750874632。 首先本地ip使用自签的ssl证书成功了，但是因为接口走http的，会报错：……was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint。即另外一个问题：https://stackoverflow.com/questions/37387711/page-loaded-over-https-but-requested-an-insecure-xmlhttprequest-endpoint。 其次，即使本地ip配置成功了ssl证书，如果要实现局域网内其他设备可访问，还得去修改路由器的hosts。","link":"/2022/02/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B2%A1%E6%9C%89-HTTPS-%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8-WebRTC/"},{"title":"记一次monorepo项目由yarn workspace+lerna迁移至pnpm","text":"首先来说一下 npm、yarn、pnpm 的区别 npm vs yarn vs pnpmnpm在 npm3 之前，安装依赖包时采用简单的递归安装方法。而在npm3及之后，采用的是模块扁平化安装。 yarn(摘自https://juejin.cn/post/6964006257715838984)yarn 出生之后，解决了历史上 npm 的某些不足，比如 npm 缺乏对于依赖的完整性和一致性保障，以及 npm 安装速度过慢的问题等，尽管 npm 发展至今，已经在很多方面向 yarn 看齐，但 yarn 的安装理念仍然需要我们关注。 yarn 提出的安装理念很好的解决了当时 npm 的依赖管理问题： 确定性。通过 yarn.lock 等机制，保证了确定性，这里的确定性包括但不限于明确的依赖版本、明确的依赖安装结构等。即在任何机器和环境下，都可以以相同的方式被安装。 模块扁平化安装。将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余。（npm 也有相同的优化) 更好的网络性能。Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制。（npm 较早的版本是顺序下载，当第一个包完全下载完成后，才会将下载控制权交给下一个包) 引入缓存机制，实现离线策略。（npm 也有类似的优化) yarn.lock 文件结构以 react 等依赖为例，先大致了解一下 yarn.lock 文件的结构以及确定依赖版本的方式： 1234567891011121314151617181920212223242526272829303132333435# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. # yarn lockfile v1 expect-jsx@^5.0.0: version &quot;5.0.0&quot; resolved &quot;[http://registry.npmjs.org/expect-jsx/-/expect-jsx-5.0.0.tgz#61761b43365f285a80eb280c785e0783bbe362c7](http://registry.npmjs.org/expect-jsx/-/expect-jsx-5.0.0.tgz#61761b43365f285a80eb280c785e0783bbe362c7)&quot; integrity sha1-YXYbQzZfKFqA6ygMeF4Hg7vjYsc= dependencies: collapse-white-space &quot;^1.0.0&quot; react &quot;^16.0.0&quot; react-element-to-jsx-string &quot;^13.0.0&quot; react-rater@^6.0.0: version &quot;6.0.0&quot; resolved &quot;[http://registry.npmjs.org/react-rater/-/react-rater-6.0.0.tgz#2e666b6e5e5c33b622541df6a7124f6c99606927](http://registry.npmjs.org/react-rater/-/react-rater-6.0.0.tgz#2e666b6e5e5c33b622541df6a7124f6c99606927)&quot; integrity sha512-NP1+rEeL3LyJqA5xF7U2fSHpISMcVeMgbQ0u/P1WmayiHccI7Ixx5GohygmJY82g7SxdJnIun2OOB6z8WTExmg== dependencies: prop-types &quot;^15.7.2&quot; react &quot;^16.8.0&quot; react-dom &quot;^16.8.0&quot; //一或多个具有相同版本范围的依赖声明，确定一个可用的版本。这就是 lockfile 的确定性。react@^16.0.0, react@^16.8.0:version &quot;16.14.0&quot; resolved &quot;[http://registry.npmjs.org/react/-/react-16.14.0.tgz#94d776ddd0aaa37da3eda8fc5b6b18a4c9a3114d](http://registry.npmjs.org/react/-/react-16.14.0.tgz#94d776ddd0aaa37da3eda8fc5b6b18a4c9a3114d)&quot; integrity sha512-0X2CImDkJGApiAlcf0ODKIneSwBPhqJawOa5wCtKbu7ZECrmS26NvtSILynQ66cgkT/RJ4LidJOc3bUESwmU8g== dependencies: loose-envify &quot;^1.1.0&quot; object-assign &quot;^4.1.1&quot; prop-types &quot;^15.6.2&quot; //如果同一个依赖存在多个版本，那么最高版本安装在顶层目录，即 node_modules 目录。react@^17.0.1:version &quot;17.0.2&quot; resolved &quot;[http://registry.npmjs.org/react/-/react-17.0.2.tgz#d0b5cc516d29eb3eee383f75b62864cfb6800037](http://registry.npmjs.org/react/-/react-17.0.2.tgz#d0b5cc516d29eb3eee383f75b62864cfb6800037)&quot; integrity sha512-gnhPt75i/dq/z3/6q/0asP78D0u592D5L1pd7M8P+dck6Fu/jJeL6iVVK23fptSUZj8Vjf++7wXA8UNclGQcbA== dependencies: loose-envify &quot;^1.1.0&quot; object-assign &quot;^4.1.1&quot; 从上面依赖版本描述的信息中，可以确定以下几点： 所有依赖，不管是项目声明的依赖，还是依赖的依赖，都是扁平化管理。 依赖的版本是由所有依赖的版本声明范围确定的，具备相同版本声明范围的依赖归结为一类，确定一个该范围下的依赖版本。如果同一个依赖多个版本共存，那么会并列归类。 每个依赖确定的版本中，是由以下几项构成： 多个依赖的声明版本，且符合 semver 规范； 确定的版本号 version 字段； 版本的完整性验证字段 依赖列表 相比 npm，Yarn 一个显著区别是 yarn.lock 中子依赖的版本号不是固定版本。 也就是说单独一个 yarn.lock 确定不了 node_modules 目录结构，还需要和 package.json 文件进行配合。 pnpm采用软链+硬链的方式进行包管理，使用 npm 或 Yarn Classic 安装依赖项时，所有包都被提升到模块目录的根目录。 因此，项目可以访问到未被添加进当前项目的依赖。 默认情况下，pnpm 使用软链的方式将项目的直接依赖添加进模块文件夹的根目录，而通过硬链为你节省了磁盘空间并提升安装速度。 为什么使用 pnpm 节省了磁盘空间 解决了扁平化依赖树带来的问题： 模块可以访问它们不依赖的包 扁平化依赖树的算法非常复杂 一些包必须复制到一个项目的 node_modules 文件夹中 安全。与 Yarn 一样，pnpm 有一个特殊文件，其中包含所有已安装包的校验和，以在执行每个已安装包的代码之前验证其完整性。 离线模式。 pnpm 将所有下载的包压缩包保存在本地注册表镜像中。当包在本地可用时，它从不发出请求。使用 –offline 参数，可以完全禁止 HTTP 请求。 速度。 pnpm 不仅比 npm 快，而且比 Yarn 快。无论是冷缓存还是热缓存，它都比 Yarn 快。 Yarn 从缓存中复制文件，而 pnpm 只是从全局存储中链接它们。 迁移yarn 迁移至 pnpm 很简单，官网也有提供可能遇到的问题以及解决方案。 首先可以通过 pnpm import 从另一个软件包管理器的 lock 文件生成 pnpm-lock.yaml。 支持的源文件： package-lock.json npm-shrinkwrap.json(类似package-lock.json) yarn.lock (v6.14.0 起) 请注意，如果您有要为其导入依赖项的工作区，那么在导入之前，您需要在 pnpm-workspace.yaml 文件中声明它们。 遇到的问题在迁移的过程中，发现有子 package 打包失败。查看了下依赖，发现导致打包的原因是： 该 package 有个 npm package，我们暂时就叫它 npm-packageA。然后 npm-packageA 依赖 npm-packageB，而 npm-packageB 被提升到了根目录下的 node_modules/.pnpm 里，所以导致了打包失败。 解决方案：根目录下添加 .npmrc 文件，并输入 shamefully-hoist=true 即可解决。 shamefully-hoist vs node-linker vs public-hoist-pattern摘自群里大佬的讨论： 目前使用 pnpm 来作为 electorn 项目的库管理工具时，在打包后运行，会报错找不到模块，目前的解决方案有 三种： 移除 node_module，把依赖打成 vendor.js 使用 pnpm 的 node-linker = hoisted 使用 pnpm 的 public-hoist-pattern = * 或者 shamefully-hoist = true 其中 2 和 3 的区别为:node-linker = hoisted 是真正意义上的 和 yarn 的管理方式一样public-hoist-pattern = * 或者 shamefully-hoist = true 的方式还是基于 pnpm 的管理方式，只是在 node_modules 层里，做了一次软链接 对比 shamefully-hoist 和 node-linkershamefully-hoist=true: node-linker=hoisted 参考资料: https://juejin.cn/post/7003593666581233694#heading-7 https://juejin.cn/post/6964006257715838984 https://github.com/worldzhao/blog/issues/9 https://pnpm.io/zh/blog/2020/05/27/flat-node-modules-is-not-the-only-way https://pnpm.io/zh/symlinked-node-modules-structure https://www.kochan.io/nodejs/why-should-we-use-pnpm.html","link":"/2022/02/21/%E8%AE%B0%E4%B8%80%E6%AC%A1monorepo%E9%A1%B9%E7%9B%AE%E7%94%B1yarn-workspace-lerna%E8%BF%81%E7%A7%BB%E8%87%B3pnpm/"},{"title":"记一次数据过大导致safari渲染卡死","text":"在一次项目开发中，Chrome 调试移动端项目没问题，但是在移动端的 safari 下，会导致 safari 卡死。 后经排查，是将 base64 的数据直接渲染到页面而导致的， 所以解决办法就是过滤掉 base64 的数据渲染。 说一下为什么要把 base64 渲染到页面，因为该项目是作为一个介绍 sdk 的使用姿势，然后展示数据。","link":"/2022/02/18/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%87%B4safari%E6%B8%B2%E6%9F%93%E5%8D%A1%E6%AD%BB/"},{"title":"自定义pre-commit脚本","text":"需求背景QNSolutions_Web 是一个多项目集成的 repo，front 下是多个项目，而 solution 下是一个 monorepo。 现需要实现当某个项目中有文件变更 commit 时，只对该项目进行 lint-staged 操作，而不是对整个 repo 进行 lint-staged 操作。 Repo 结构如下： 12345678910111213.├── portal│ └── front│ ├── portal-solution│ ├── portal-solution-admin│ ├── portal-solution-desktop│ └── portal-solution-dp-admin├── solution│ └── packages│ ├── solution-a│ ├── solution-b│ ├── solution-c│ └── ... 实现思路 遍历所有项目，找到包含 package.json 且存在 lint-staged 命令的目录 使用 git diff 来检查项目目录下的文件是否在提交列表中 执行 lint-staged 命令 脚本实现如下： 1234567891011121314151617181920212223#!/usr/bin/env sh# 找到包含 package.json 且存在 lint-staged 命令的目录projects=$(find . -type d -name &quot;node_modules&quot; -prune -o -type f -name &quot;package.json&quot; -exec grep -q &quot;lint-staged&quot; {} \\; -exec dirname {} \\;)# 将发生文件变更的项目存储在 changed_projects 变量中changed_projects=&quot;&quot;# 遍历每个项目，检查是否有文件变更for project in $projects; do # 使用 git diff 来检查项目目录下的文件是否在提交列表中 cd &quot;$project&quot; if git diff --cached --name-only --relative | grep -Fq &quot;&quot;; then changed_projects=&quot;$changed_projects $project&quot; fi cd - &gt; /dev/nulldone# 执行 lint-staged 命令for project in $changed_projects; do echo &quot;Running lint-staged for project: $project&quot; (cd &quot;$project&quot; &amp;&amp; pnpm install &amp;&amp; pnpm run lint-staged)done","link":"/2023/10/12/%E8%87%AA%E5%AE%9A%E4%B9%89pre-commit%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"webRTC","slug":"webRTC","link":"/tags/webRTC/"}],"categories":[]}